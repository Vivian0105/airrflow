[["index.html", "Immcantation - enchantR Find Threshold 1 Input 1.1 Parameters 1.2 Data Sources 2 Calculate Threshold for Clonal Relationships 2.1 distToNearest plot 2.2 Find threshold 3 Save 4 Software versions", " Immcantation - enchantR Find Threshold Updated: Tue Jan 28 16:42:19 2025 1 Input 1.1 Parameters Code printParams(params) Table 1.1: Input parameters. 1.2 Data Sources Code # Read repertoires, # keep only needed columns selected_columns &lt;- unique(c(&quot;sample_id&quot;, &quot;sequence_id&quot;, params$cloneby, params$crossby, &quot;v_call&quot;, &quot;j_call&quot;, &quot;junction&quot;, &quot;cell_id&quot;, params$singlecell, &quot;locus&quot;)) db &lt;- readInput(params[[&#39;input&#39;]], col_select=selected_columns) input_sizes &lt;- db %&gt;% count(input_file) input_sizes &lt;- input_sizes %&gt;% rename(&quot;sequences&quot; = &quot;n&quot;) eetable(input_sizes)$table Code input_size &lt;- nrow(db) is_heavy &lt;- isHeavyChain(db[[&#39;locus&#39;]]) singlecell &lt;- params$singlecell # Check for single cell label if (!is.null(singlecell)) { if (singlecell %in% colnames(db)) { db[[ singlecell ]] &lt;- as.logical(db[[ singlecell ]] ) } else { stop(&quot;`&quot;, singlecell, &quot;` is not a valid field in `db`.&quot;) } } else { singlecell &lt;- &quot;single_cell&quot; db[[singlecell]] &lt;- F if (&quot;cell_id&quot; %in% colnames(db)) { message(&quot;Setting `singlecell` using `cell_id`.&quot;) db[[singlecell]][!db[[&#39;cell_id&#39;]] %in% c(NA, &#39;&#39;)] &lt;- T } } na_single &lt;- is.na(db[[singlecell]]) if (sum(na_single)&gt;0) { warning(sum(na_single), &quot; sequences are missing single cell information. Using single_cell=F&quot;) db[[singlecell]][na_single] &lt;- FALSE } bulk_heavy &lt;- is_heavy &amp; !db[[singlecell]] sc_heavy &lt;- is_heavy &amp; db[[singlecell]] bulk_dtn &lt;- data.frame() sc_dtn &lt;- data.frame() subsample &lt;- params[[&#39;subsample&#39;]] if (subsample %in% c(NA, 0, NULL)) { subsample &lt;- NULL } Number of sequences loaded: 12307. Code input_summary &lt;- db %&gt;% group_by(!!!rlang::syms(unique(c(&quot;sample_id&quot;,params$cloneby, &quot;locus&quot;)))) %&gt;% summarize(n=n(), .groups=&quot;drop&quot;) %&gt;% pivot_wider(names_from=locus, values_from=n) input_summary_table &lt;- eetable(input_summary) input_summary_table$table Table 1.2: Input data summary. 2 Calculate Threshold for Clonal Relationships The shazam package provides methods to find an appropriate distance threshold to determine clonal relationships for each dataset (distToNearest and findThreshold) by generating a distribution of distances between each sequence and its closest non-identical neighbor. Typically, the distance-to-nearest distribution for a repertoire is bimodal. The first mode (on the left) represents sequences that have at least one clonal relative in the dataset, while the second mode (on the right) is representative of the sequences that do not have any clonal relatives in the data. A reasonable threshold will separate these two modes of the distribution. The distance may be selected manually, or findThreshold can be used to automatically select a threshold. Specifying the cross argument to distToNearest forces distance calculations to be performed across groups, such that the nearest neighbor of each sequence will always be a sequence in a different group. Code if (any(db[[singlecell]] == F) &amp;&amp; sum(bulk_heavy)&gt;0) { message(&quot;Using &quot;,sum(bulk_heavy), &quot; bulk heavy chain sequences.&quot;) # Add distances to nearest neighbor within a &quot;cloneby&quot; group bulk_dtn &lt;- distToNearest(db[bulk_heavy,] , fields=params$cloneby, sequenceColumn=&quot;junction&quot;, vCallColumn=&quot;v_call&quot;, jCallColumn=&quot;j_call&quot;, model=&quot;ham&quot;, first=FALSE, VJthenLen=TRUE, normalize=&quot;len&quot;, nproc=params$nproc, subsample = subsample) bulk_dtn &lt;- distToNearest(bulk_dtn, fields=NULL, cross=params$crossby, sequenceColumn=&quot;junction&quot;, vCallColumn=&quot;v_call&quot;, jCallColumn=&quot;j_call&quot;, model=&quot;ham&quot;, first=FALSE, VJthenLen=TRUE, normalize=&quot;len&quot;, nproc=params$nproc, subsample = subsample) } Code if (any(db[[singlecell]] == T) &amp;&amp; sum(sc_heavy)&gt;0) { message(&quot;Using &quot;,sum(sc_heavy), &quot; sc heavy chain sequences.&quot;) # Create unique cell_id # db[[&#39;cell_id&#39;]] &lt;- paste0(db[[&#39;sample_id&#39;]],db[[&#39;cell_id&#39;]]) # Add distances to nearest neighbor within a &quot;cloneby&quot; group sc_dtn &lt;- distToNearest(db[sc_heavy,] , fields=params$cloneby, sequenceColumn=&quot;junction&quot;, vCallColumn=&quot;v_call&quot;, jCallColumn=&quot;j_call&quot;, model=&quot;ham&quot;, first=FALSE, VJthenLen=TRUE, normalize=&quot;len&quot;, nproc=params$nproc, cellIdColumn = &quot;cell_id&quot;, locusColumn = &quot;locus&quot;, onlyHeavy = TRUE, subsample = subsample) # Add distances to nearest neighbor across a &quot;crossby&quot; group sc_dtn &lt;- distToNearest(sc_dtn, fields=NULL, cross=params$crossby, sequenceColumn=&quot;junction&quot;, vCallColumn=&quot;v_call&quot;, jCallColumn=&quot;j_call&quot;, model=&quot;ham&quot;, first=FALSE, VJthenLen=TRUE, normalize=&quot;len&quot;, nproc=params$nproc, cellIdColumn = &quot;cell_id&quot;, locusColumn = &quot;locus&quot;, onlyHeavy = TRUE, subsample = subsample) } 2.1 distToNearest plot Code caption &lt;- paste0(&quot;Distribution of the distance to the nearest sequence within &quot;, paste(params$cloneby, collapse=&quot;,&quot;),&quot;, displayed by sample_id. When &quot;, &quot;cross &quot;,paste(params$crossby, collapse=&quot;,&quot;), &quot; distances are available, they are shown in an inverse y-axis.&quot;) if (!is.null(subsample)) { caption &lt;- paste0(caption,&quot; Subsampling requested: &quot;, subsample, &quot;.&quot;) } wrap_formula &lt;- as.formula(paste0( c( singlecell, &quot;~&quot;, paste(unique(c(&quot;sample_id&quot;, params$clone_by)), collapse = &quot;+&quot;) ),collapse=&quot;&quot;) ) db &lt;- bind_rows(bulk_dtn,sc_dtn) dtnplot &lt;- NULL if (any(!is.na(db[[&#39;dist_nearest&#39;]]))) { dtnplot &lt;- ggplot(db) + geom_histogram(aes(dist_nearest, fill=sample_id),binwidth = 0.01) + scale_x_continuous( breaks = seq(0, 1, 0.1) ) } else { cat(&quot;All `dist_nearest` values are NA.&quot;) warning(&quot;All `dist_nearest` values are NA.&quot;) } if (&quot;cross_dist_nearest&quot; %in% c(colnames(bulk_dtn),colnames(sc_dtn))) { if (any(!is.na(db[[&#39;cross_dist_nearest&#39;]]))) { dtnplot &lt;- dtnplot + geom_histogram( aes(x=cross_dist_nearest, y=-(..count..), fill=sample_id), binwidth=0.01, position=&quot;identity&quot;) + #scale_y_continuous(labels = abs) + ylab(&quot;count&quot;) } else { cat(&quot;All `cross_dist_nearest` values are NA.&quot;) warning(&quot;All `cross_dist_nearest` values are NA.&quot;) } } if (is.null(dtnplot)) { cat(&quot;All distance values are NA.&quot;) } Code dtnplot &lt;- dtnplot + facet_wrap(wrap_formula, scales = &quot;free_y&quot;, ncol=2, labeller = &quot;label_both&quot;) + expand_limits(x = 0, y =0) + theme_enchantr() + theme(legend.position = &quot;bottom&quot;) dtnplot &lt;- eeplot(dtnplot, outdir=params$outdir, file=knitr::opts_current$get(&#39;dtnplot&#39;), caption=caption ) ggplotly(dtnplot + theme(panel.spacing=unit(2, &#39;lines&#39;), legend.position=&quot;none&quot;)) Figure 2.1: Distribution of the distance to the nearest sequence within subject_id, displayed by sample_id. When cross subject_id distances are available, they are shown in an inverse y-axis. ggplot file: dtnplot.RData Code caption &lt;- dtnplot$enchantr$html_caption 2.2 Find threshold findThreshold uses the distribution of distances calculated in the previous step to determine an appropriate threshold for the dataset. 2.2.1 Threshold(s) summary table Code # This chunk runs when all dist_nearest values are NA threshold &lt;- NA threshold_summary &lt;- data.frame(mean_threshold = NA) cat(&quot;All `dist_nearest` values are NA. Skipping threshold analysis.&quot;) Code cross_dist_nearest &lt;- NULL if (&quot;cross_dist_nearest&quot; %in% colnames(db)) { if (any(!is.na(db[[&#39;cross_dist_nearest&#39;]]))) { cross_dist_nearest &lt;- &quot;cross_dist_nearest&quot; } else { warning(&quot;All `cross_dist_nearest` values are NA.&quot;) } } threshold &lt;- findThresholdDb(db, distanceColumn=&quot;dist_nearest&quot;, crossDistanceColumn=cross_dist_nearest, method=params$findthreshold_method, model=params$findthreshold_model, edge=params$findthreshold_edge, cutoff = params$findthreshold_cutoff, spc = params$findthreshold_spc, nproc=params$nproc, fields=params$cloneby, subsample=subsample) threshold_summary &lt;- gmmSummary(threshold) %&gt;% mutate(mean_threshold=mean(threshold, na.rm=TRUE)) mean_threshold &lt;- round(threshold_summary$mean_threshold[1],2) tab_caption &lt;- paste0(&quot;Summary of threshold values, p-value from Hartigans dip statistic (HDS) test with &lt;0.05 indicating significant bimodality. Mean threshold is: &quot;, mean_threshold) if (!is.null(subsample)) { tab_caption &lt;- paste0(tab_caption,&quot; Subsampling requested: &quot;, subsample, &quot;.&quot;) } tab &lt;- eetable(threshold_summary, outdir=params$outdir, file=paste(params$outname, &quot;threshold-summary&quot;, sep=&quot;_&quot;), caption=tab_caption) tab$table %&gt;% DT::formatRound(columns=setdiff(colnames(threshold_summary)[-1],&quot;model&quot;), digits=3) Table 2.1: Summary of threshold values, p-value from Hartigans&lt;U+2019&gt; dip statistic (HDS) test with &lt;0.05 indicating significant bimodality. Mean threshold is: 0.1 File can be found here: all_reps_threshold-summary.tsv Code caption_list &lt;- NULL tmp &lt;- lapply(threshold, function(thr) { this_thr &lt;- NA if (!is.null(attributes(thr$GmmThreshold))) { this_thr &lt;- round(attributes(thr$GmmThreshold)$threshold,2) } cat (&quot;\\n\\n### &quot;,paste(c(params$crossby, &quot; &quot;, thr[[&#39;fields&#39;]], &quot;, estimated threshold:&quot;, this_thr),collapse=&quot; &quot;),&quot;\\n\\n&quot;) fn &lt;- paste(c(thr[[&#39;fields&#39;]],&quot;dtnthrplot&quot;),collapse=&quot;_&quot;) dtnthrcaption &lt;- paste0(&quot;Distribution of the distance to the nearest sequence within &quot;, paste(params$cloneby, collapse=&quot;,&quot;),&quot; (&quot;, paste(thr[[&#39;fields&#39;]],collapse=&quot;_&quot;) ,&quot;). When &quot;, &quot;cross &quot;,paste(params$crossby, collapse=&quot;,&quot;), &quot; distances are available, they are shown in an inverse y-axis.&quot;) p &lt;- thr[[&#39;plot&#39;]] + scale_x_continuous( breaks = seq(0, 1, 0.1) ) p &lt;- eeplot(p, outdir=params$outdir, file=fn, caption=dtnthrcaption ) print(p) caption_list &lt;&lt;- c(caption_list, p$enchantr$html_caption) }) 2.2.2 subject_id M5 , estimated threshold: 0.06 Figure 2.2: Distribution of the distance to the nearest sequence within subject_id (M5). When cross subject_id distances are available, they are shown in an inverse y-axis. ggplot file: M5_dtnthrplot.RData 2.2.3 subject_id M4 , estimated threshold: 0.14 Figure 2.3: Distribution of the distance to the nearest sequence within subject_id (M4). When cross subject_id distances are available, they are shown in an inverse y-axis. ggplot file: M4_dtnthrplot.RData 3 Save Code # pass &lt;- db[[&#39;collapse_pass&#39;]] if (!is.null(params$outname)) { output_fn &lt;- paste(params$outname,&quot;threshold-pass.tsv&quot;, sep=&quot;_&quot;) } else { output_fn &lt;- sub(&quot;.tsv$&quot;, &quot;_threshold-pass.tsv&quot;, basename(params$input)) } if (!is.null(params$log)) { log_fn &lt;- paste0(params$log,&quot;.txt&quot;) } else { log_fn &lt;- sub(&quot;threshold-pass.tsv$&quot;, &quot;command_log.txt&quot;, basename(output_fn)) } # write_rearrangement(db , file=output_fn) tables_dir &lt;- file.path(params$outdir,&quot;tables&quot;) if (!dir.exists(tables_dir)) { dir.create(tables_dir, recursive = T) } cat(threshold_summary[[&#39;mean_threshold&#39;]][1], file=file.path(tables_dir, sub(&quot;threshold-pass.tsv$&quot;, &quot;threshold-mean.tsv&quot; ,output_fn)), append=F ) Code cat(&quot;START&gt; FindThreshold&quot;, file=log_fn, append=F) cat(paste0(&quot;\\nFILE&gt; &quot;,basename(params$input)), file=log_fn, append=T) cat(paste0(&quot;\\nOUTPUT&gt; &quot;,basename(output_fn)), file=log_fn, append=T) cat(paste0(&quot;\\nPASS&gt; &quot;,nrow(db)), file=log_fn, append=T) cat(paste0(&quot;\\nFAIL&gt; &quot;,input_size-nrow(db)), file=log_fn, append=T) 4 Software versions Code sessionInfo() ## R version 4.4.2 (2024-10-31) ## Platform: x86_64-redhat-linux-gnu ## Running under: Fedora Linux 40 (Container Image) ## ## Matrix products: default ## BLAS/LAPACK: FlexiBLAS OPENBLAS-OPENMP; LAPACK version 3.11.0 ## ## locale: ## [1] C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] R.utils_2.12.3 R.oo_1.27.0 R.methodsS3_1.8.2 plotly_4.10.4 ## [5] tidyr_1.3.1 shazam_1.2.0 alakazam_1.3.0 ggplot2_3.5.1 ## [9] airr_1.5.0 dplyr_1.1.4 DT_0.33 enchantr_0.1.19 ## ## loaded via a namespace (and not attached): ## [1] bitops_1.0-9 gridExtra_2.3 ## [3] rlang_1.1.4 magrittr_2.0.3 ## [5] clue_0.3-66 GetoptLong_1.0.5 ## [7] ade4_1.7-22 matrixStats_1.4.1 ## [9] compiler_4.4.2 png_0.1-8 ## [11] vctrs_0.6.5 stringr_1.5.1 ## [13] pkgconfig_2.0.3 shape_1.4.6.1 ## [15] crayon_1.5.3 fastmap_1.2.0 ## [17] XVector_0.46.0 labeling_0.4.3 ## [19] ggraph_2.2.1 utf8_1.2.4 ## [21] Rsamtools_2.22.0 rmarkdown_2.29 ## [23] tzdb_0.4.0 UCSC.utils_1.2.0 ## [25] bit_4.5.0 purrr_1.0.2 ## [27] xfun_0.49 zlibbioc_1.52.0 ## [29] cachem_1.1.0 seqinr_4.2-36 ## [31] GenomeInfoDb_1.42.0 jsonlite_1.8.9 ## [33] progress_1.2.3 DelayedArray_0.32.0 ## [35] BiocParallel_1.40.0 tweenr_2.0.3 ## [37] parallel_4.4.2 prettyunits_1.2.0 ## [39] cluster_2.1.6 R6_2.5.1 ## [41] bslib_0.8.0 stringi_1.8.4 ## [43] RColorBrewer_1.1-3 diptest_0.77-1 ## [45] jquerylib_0.1.4 GenomicRanges_1.58.0 ## [47] bookdown_0.41 knitr_1.49 ## [49] Rcpp_1.0.13-1 SummarizedExperiment_1.36.0 ## [51] iterators_1.0.14 readr_2.1.5 ## [53] IRanges_2.40.0 Matrix_1.7-1 ## [55] igraph_2.1.1 tidyselect_1.2.1 ## [57] rstudioapi_0.17.1 abind_1.4-8 ## [59] yaml_2.3.10 viridis_0.6.5 ## [61] doParallel_1.0.17 codetools_0.2-20 ## [63] lattice_0.22-6 tibble_3.2.1 ## [65] Biobase_2.66.0 withr_3.0.2 ## [67] evaluate_1.0.1 polyclip_1.10-7 ## [69] circlize_0.4.16 Biostrings_2.74.0 ## [71] pillar_1.9.0 MatrixGenerics_1.18.0 ## [73] KernSmooth_2.23-24 foreach_1.5.2 ## [75] stats4_4.4.2 generics_0.1.3 ## [77] vroom_1.6.5 S4Vectors_0.44.0 ## [79] hms_1.1.3 munsell_0.5.1 ## [81] scales_1.3.0 glue_1.8.0 ## [83] lazyeval_0.2.2 tools_4.4.2 ## [85] data.table_1.16.2 GenomicAlignments_1.42.0 ## [87] graphlayouts_1.2.1 tidygraph_1.3.1 ## [89] grid_4.4.2 ape_5.8 ## [91] crosstalk_1.2.1 colorspace_2.1-1 ## [93] nlme_3.1-166 GenomeInfoDbData_1.2.13 ## [95] ggforce_0.4.2 cli_3.6.3 ## [97] fansi_1.0.6 S4Arrays_1.6.0 ## [99] viridisLite_0.4.2 ComplexHeatmap_2.18.0 ## [101] gtable_0.3.6 sass_0.4.9 ## [103] digest_0.6.37 BiocGenerics_0.52.0 ## [105] SparseArray_1.6.0 ggrepel_0.9.6 ## [107] rjson_0.2.23 htmlwidgets_1.6.4 ## [109] farver_2.1.2 memoise_2.0.1 ## [111] htmltools_0.5.8.1 lifecycle_1.0.4 ## [113] httr_1.4.7 GlobalOptions_0.1.2 ## [115] bit64_4.5.2 MASS_7.3-61 "]]
